// Generated by 'peg2'
// https://pub.dev/packages/peg2

import 'package:edart/fragment.dart';

class EdartParser {
  static const int _eof = 1114112;

  FormatException? error;

  int _failStart = -1;

  List _failures = [];

  bool ok = false;

  int _ch = 0;

  int _failPos = -1;

  int _pos = 0;

  String _source = '';

  List<Fragment>? parse(String source) {
    _source = source;
    _reset();
    final result = _parseFragments();
    if (!ok) {
      _buildError();
    }

    return result;
  }

  List<Fragment>? _parseFragments() {
    List<Fragment>? $0;
    final $2 = _ch;
    final $3 = _pos;
    List<Fragment>? $4;
    List<Fragment>? $5;
    final $6 = <Fragment>[];
    while (true) {
      final $7 = _parseFragment();
      if (!ok) {
        break;
      }
      $6.add($7!);
    }
    if (ok = true) {
      $5 = $6;
    }
    _parse_eof();
    if (ok) {
      $4 = $5;
    }
    if (ok) {
      $0 = $4;
    } else {
      _ch = $2;
      _pos = $3;
    }
    return $0;
  }

  Fragment? _parseFragment() {
    Fragment? $0;
    final $1 = _ch;
    final $2 = _pos;
    while (true) {
      Fragment? $4;
      _parse$Terminal16();
      if (ok) {
        final $5 = _parseDirective();
        if (ok) {
          _parseClosedTag();
          if (ok) {
            final d = $5!;
            late Fragment $$;
            $$ = Fragment.directive(d);
            $4 = $$;
          }
        }
      }
      if (ok) {
        $0 = $4;
        break;
      }
      _ch = $1;
      _pos = $2;
      Fragment? $7;
      _parse$Terminal15();
      if (ok) {
        final $8 = _parse_expression();
        if (ok) {
          _parseClosedTag();
          if (ok) {
            final e = $8!;
            late Fragment $$;
            $$ = Fragment.raw(e);
            $7 = $$;
          }
        }
      }
      if (ok) {
        $0 = $7;
        break;
      }
      _ch = $1;
      _pos = $2;
      Fragment? $10;
      _parse$Terminal14();
      if (ok) {
        final $11 = _parse_expression();
        if (ok) {
          _parseClosedTag();
          if (ok) {
            final e = $11!;
            late Fragment $$;
            $$ = Fragment.expression(e);
            $10 = $$;
          }
        }
      }
      if (ok) {
        $0 = $10;
        break;
      }
      _ch = $1;
      _pos = $2;
      Fragment? $13;
      _parse_$LessThanSign$PercentSign();
      if (ok) {
        final $14 = _parse_source();
        _parseClosedTag();
        if (ok) {
          final s = $14!;
          late Fragment $$;
          $$ = Fragment.code(s);
          $13 = $$;
        }
      }
      if (ok) {
        $0 = $13;
        break;
      }
      _ch = $1;
      _pos = $2;
      Fragment? $16;
      final $17 = _parse_text();
      if (ok) {
        final s = $17!;
        late Fragment $$;
        $$ = Fragment.text(s);
        $16 = $$;
      }
      if (ok) {
        $0 = $16;
        break;
      }
      _ch = $1;
      break;
    }
    return $0;
  }

  String? _parseClosedTag() {
    _parse_$PercentSign$GreaterThanSign();
    return null;
  }

  Directive? _parseDirective() {
    Directive? $0;
    final $2 = _ch;
    final $3 = _pos;
    Directive? $4;
    final $5 = _parse_indentifier();
    if (ok) {
      final $6 = _parseAttributes();
      final n = $5!;
      final a = $6!;
      late Directive $$;
      $$ = Directive(n, a);
      $4 = $$;
    }
    if (ok) {
      $0 = $4;
    } else {
      _ch = $2;
      _pos = $3;
    }
    return $0;
  }

  List<Attribute>? _parseAttributes() {
    List<Attribute>? $0;
    List<Attribute>? $2;
    List<Attribute>? $3;
    final $4 = <Attribute>[];
    while (true) {
      final $5 = _parseAttribute();
      if (!ok) {
        break;
      }
      $4.add($5!);
    }
    if (ok = true) {
      $3 = $4;
    }
    $2 = $3;
    if (ok) {
      $0 = $2;
    }
    return $0;
  }

  Attribute? _parseAttribute() {
    Attribute? $0;
    final $2 = _ch;
    final $3 = _pos;
    Attribute? $4;
    final $5 = _parse_indentifier();
    if (ok) {
      _parse_$EqualSign();
      if (ok) {
        final $6 = _parse_string();
        if (ok) {
          final n = $5!;
          final v = $6!;
          late Attribute $$;
          $$ = Attribute(n, v);
          $4 = $$;
        }
      }
    }
    if (ok) {
      $0 = $4;
    } else {
      _ch = $2;
      _pos = $3;
    }
    return $0;
  }

  dynamic _parse_eof() {
    _failPos = _pos;
    _parse$$eof();
    if (!ok) {
      _fail('\'eof\'');
    }
    return null;
  }

  String? _parse_expression() {
    _failPos = _pos;
    String? $0;
    String? $2;
    String? $3;
    final $4 = _pos;
    var $5 = 0;
    while (true) {
      final $6 = _ch;
      final $7 = _pos;
      final $8 = _failPos;
      final $9 = _failStart;
      final $10 = _failures;
      _matchString('%>');
      _ch = $6;
      _pos = $7;
      _failPos = $8;
      _failStart = $9;
      _failures = $10;
      ok = !ok;
      if (ok) {
        _matchAny();
      }
      if (!ok) {
        break;
      }
      $5++;
    }
    ok = $5 != 0;
    if (ok) {
      $3 = _source.substring($4, _pos);
    }
    if (ok) {
      $2 = $3;
    }
    if (ok) {
      $0 = $2;
    } else {
      _fail('\'expression\'');
    }
    return $0;
  }

  String? _parse_indentifier() {
    _failPos = _pos;
    String? $0;
    final $2 = _ch;
    final $3 = _pos;
    String? $4;
    String? $5;
    final $6 = _pos;
    final $7 = _ch;
    final $8 = _pos;
    const $9 = [65, 90, 95, 95, 97, 122];
    _matchRanges($9);
    if (ok) {
      while (true) {
        const $10 = [48, 57, 65, 90, 95, 95, 97, 122];
        _matchRanges($10);
        if (!ok) {
          break;
        }
      }
      ok = true;
    }
    if (!ok) {
      _ch = $7;
      _pos = $8;
    }
    if (ok) {
      $5 = _source.substring($6, _pos);
    }
    if (ok) {
      _parse$$white();
      final i = $5!;
      $4 = i;
    }
    if (ok) {
      $0 = $4;
    } else {
      _ch = $2;
      _pos = $3;
      _fail('\'indentifier\'');
    }
    return $0;
  }

  String? _parse_source() {
    String? $0;
    String? $2;
    String? $3;
    final $4 = _pos;
    while (true) {
      final $5 = _ch;
      final $6 = _pos;
      final $7 = _failPos;
      final $8 = _failStart;
      final $9 = _failures;
      _matchString('%>');
      _ch = $5;
      _pos = $6;
      _failPos = $7;
      _failStart = $8;
      _failures = $9;
      ok = !ok;
      if (ok) {
        _matchAny();
      }
      if (!ok) {
        break;
      }
    }
    ok = true;
    if (ok) {
      $3 = _source.substring($4, _pos);
    }
    $2 = $3;
    if (ok) {
      $0 = $2;
    }
    return $0;
  }

  String? _parse_string() {
    _failPos = _pos;
    String? $0;
    final $2 = _ch;
    final $3 = _pos;
    String? $4;
    _matchChar(34, '"');
    if (ok) {
      List<int>? $5;
      final $6 = <int>[];
      while (true) {
        final $7 = _parse$$char();
        if (!ok) {
          break;
        }
        $6.add($7!);
      }
      if (ok = true) {
        $5 = $6;
      }
      _matchChar(34, '"');
      if (ok) {
        _parse$$white();
        final c = $5!;
        late String $$;
        $$ = String.fromCharCodes(c);
        $4 = $$;
      }
    }
    if (ok) {
      $0 = $4;
    } else {
      _ch = $2;
      _pos = $3;
      _fail('\'string\'');
    }
    return $0;
  }

  String? _parse_text() {
    _failPos = _pos;
    String? $0;
    String? $2;
    String? $3;
    final $4 = _pos;
    final $5 = _ch;
    final $6 = _pos;
    final $7 = _ch;
    final $8 = _pos;
    final $9 = _failPos;
    final $10 = _failStart;
    final $11 = _failures;
    _parse$$eof();
    _ch = $7;
    _pos = $8;
    _failPos = $9;
    _failStart = $10;
    _failures = $11;
    ok = !ok;
    if (ok) {
      while (true) {
        final $12 = _ch;
        final $13 = _pos;
        final $14 = _failPos;
        final $15 = _failStart;
        final $16 = _failures;
        _matchString('<%');
        _ch = $12;
        _pos = $13;
        _failPos = $14;
        _failStart = $15;
        _failures = $16;
        ok = !ok;
        if (ok) {
          final $17 = _ch;
          final $18 = _pos;
          final $19 = _failPos;
          final $20 = _failStart;
          final $21 = _failures;
          _parse$$newline();
          _ch = $17;
          _pos = $18;
          _failPos = $19;
          _failStart = $20;
          _failures = $21;
          ok = !ok;
          if (ok) {
            _matchAny();
          }
        }
        if (!ok) {
          break;
        }
      }
      ok = true;
      _parse$$newline();
      ok = true;
    }
    if (!ok) {
      _ch = $5;
      _pos = $6;
    }
    if (ok) {
      $3 = _source.substring($4, _pos);
    }
    if (ok) {
      $2 = $3;
    }
    if (ok) {
      $0 = $2;
    } else {
      _fail('\'text\'');
    }
    return $0;
  }

  String? _parse_$EqualSign() {
    _failPos = _pos;
    final $0 = _ch;
    final $1 = _pos;
    _matchChar(61, '=');
    if (ok) {
      _parse$$white();
    }
    if (!ok) {
      _ch = $0;
      _pos = $1;
      _fail('\'=\'');
    }
    return null;
  }

  String? _parse_$LessThanSign$PercentSign() {
    _failPos = _pos;
    final $0 = _ch;
    final $1 = _pos;
    _matchString('<%');
    if (ok) {
      _parse$$white();
    }
    if (!ok) {
      _ch = $0;
      _pos = $1;
      _fail('\'<%\'');
    }
    return null;
  }

  String? _parse$Terminal14() {
    _failPos = _pos;
    final $0 = _ch;
    final $1 = _pos;
    _matchString('<%=');
    if (ok) {
      _parse$$white();
    }
    if (!ok) {
      _ch = $0;
      _pos = $1;
      _fail('\'<%=\'');
    }
    return null;
  }

  String? _parse$Terminal15() {
    _failPos = _pos;
    final $0 = _ch;
    final $1 = _pos;
    _matchString('<%==');
    if (ok) {
      _parse$$white();
    }
    if (!ok) {
      _ch = $0;
      _pos = $1;
      _fail('\'<%==\'');
    }
    return null;
  }

  String? _parse$Terminal16() {
    _failPos = _pos;
    final $0 = _ch;
    final $1 = _pos;
    _matchString('<%@');
    if (ok) {
      _parse$$white();
    }
    if (!ok) {
      _ch = $0;
      _pos = $1;
      _fail('\'<%@\'');
    }
    return null;
  }

  String? _parse_$PercentSign$GreaterThanSign() {
    _failPos = _pos;
    _matchString('%>');
    if (!ok) {
      _fail('\'%>\'');
    }
    return null;
  }

  int? _parse$$char() {
    int? $0;
    final $1 = _ch;
    while (true) {
      int? $3;
      final $4 = _matchRange(32, 33);
      if (ok) {
        $3 = $4;
      }
      if (ok) {
        $0 = $3;
        break;
      }
      _ch = $1;
      int? $6;
      final $7 = _matchRange(35, 91);
      if (ok) {
        $6 = $7;
      }
      if (ok) {
        $0 = $6;
        break;
      }
      _ch = $1;
      int? $9;
      final $10 = _matchRange(93, 1114111);
      if (ok) {
        $9 = $10;
      }
      if (ok) {
        $0 = $9;
        break;
      }
      _ch = $1;
      break;
    }
    return $0;
  }

  dynamic _parse$$eof() {
    final $0 = _ch;
    final $1 = _pos;
    final $2 = _failPos;
    final $3 = _failStart;
    final $4 = _failures;
    _matchAny();
    _ch = $0;
    _pos = $1;
    _failPos = $2;
    _failStart = $3;
    _failures = $4;
    ok = !ok;
    return null;
  }

  dynamic _parse$$newline() {
    final $0 = _ch;
    while (true) {
      _matchChar(10, 10);
      if (ok) {
        break;
      }
      _ch = $0;
      _matchString('\r\n');
      if (ok) {
        break;
      }
      _ch = $0;
      break;
    }
    return null;
  }

  List? _parse$$white() {
    while (true) {
      final $0 = _ch;
      while (true) {
        const $1 = [9, 10, 32, 32];
        _matchRanges($1);
        if (ok) {
          break;
        }
        _ch = $0;
        _matchString('\r\n');
        if (ok) {
          break;
        }
        _ch = $0;
        break;
      }
      if (!ok) {
        break;
      }
    }
    ok = true;
    return null;
  }

  void _buildError() {
    final names = <String>[];
    final ends = <int>[];
    var failEnd = 0;
    for (var i = 0; i < _failures.length; i += 2) {
      final name = _failures[i] as String;
      final end = _failures[i + 1] as int;
      if (failEnd < end) {
        failEnd = end;
      }

      names.add(name);
      ends.add(end);
    }

    final temp = <String>[];
    for (var i = 0; i < names.length; i++) {
      if (ends[i] == failEnd) {
        temp.add(names[i]);
      }
    }

    final expected = temp.toSet().toList();
    expected.sort();
    final sink = StringBuffer();
    if (_failStart == failEnd) {
      if (failEnd < _source.length) {
        sink.write('Unexpected character ');
        final ch = _getChar(_failStart);
        if (ch >= 32 && ch < 126) {
          sink.write('\'');
          sink.write(String.fromCharCode(ch));
          sink.write('\'');
        } else {
          sink.write('(');
          sink.write(ch);
          sink.write(')');
        }
      } else {
        sink.write('Unexpected end of input');
      }

      if (expected.isNotEmpty) {
        sink.write(', expected: ');
        sink.write(expected.join(', '));
      }
    } else {
      sink.write('Unterminated ');
      if (expected.isEmpty) {
        sink.write('unknown token');
      } else if (expected.length == 1) {
        sink.write('token ');
        sink.write(expected[0]);
      } else {
        sink.write('tokens ');
        sink.write(expected.join(', '));
      }
    }

    error = FormatException(sink.toString(), _source, _failStart);
  }

  void _fail(String name) {
    if (_pos < _failStart) {
      return;
    }

    if (_failStart < _pos) {
      _failStart = _pos;
      _failures = [];
    }

    _failures.add(name);
    _failures.add(_failPos);
  }

  int _getChar(int pos) {
    if (pos < _source.length) {
      var ch = _source.codeUnitAt(pos);
      if (ch >= 0xD800 && ch <= 0xDBFF) {
        if (pos + 1 < _source.length) {
          final ch2 = _source.codeUnitAt(pos + 1);
          if (ch2 >= 0xDC00 && ch2 <= 0xDFFF) {
            ch = ((ch - 0xD800) << 10) + (ch2 - 0xDC00) + 0x10000;
          } else {
            throw FormatException('Unpaired high surrogate', _source, pos);
          }
        } else {
          throw FormatException('The source has been exhausted', _source, pos);
        }
      } else {
        if (ch >= 0xDC00 && ch <= 0xDFFF) {
          throw FormatException(
              'UTF-16 surrogate values are illegal in UTF-32', _source, pos);
        }
      }

      return ch;
    }

    return _eof;
  }

  int? _matchAny() {
    if (_ch == _eof) {
      if (_failPos < _pos) {
        _failPos = _pos;
      }

      ok = false;
      return null;
    }

    final ch = _ch;
    _pos += _ch <= 0xffff ? 1 : 2;
    _ch = _getChar(_pos);
    ok = true;
    return ch;
  }

  T? _matchChar<T>(int ch, T? result) {
    if (ch != _ch) {
      if (_failPos < _pos) {
        _failPos = _pos;
      }

      ok = false;
      return null;
    }

    _pos += _ch <= 0xffff ? 1 : 2;
    _ch = _getChar(_pos);
    ok = true;
    return result;
  }

  int? _matchRange(int start, int end) {
    if (_ch >= start && _ch <= end) {
      final ch = _ch;
      _pos += _ch <= 0xffff ? 1 : 2;
      _ch = _getChar(_pos);
      ok = true;
      return ch;
    }

    if (_failPos < _pos) {
      _failPos = _pos;
    }

    ok = false;
    return null;
  }

  int? _matchRanges(List<int> ranges) {
    // Use binary search
    for (var i = 0; i < ranges.length; i += 2) {
      if (ranges[i] <= _ch) {
        if (ranges[i + 1] >= _ch) {
          final ch = _ch;
          _pos += _ch <= 0xffff ? 1 : 2;
          _ch = _getChar(_pos);
          ok = true;
          return ch;
        }
      } else {
        break;
      }
    }

    ok = false;
    if (_failPos < _pos) {
      _failPos = _pos;
    }

    return null;
  }

  String? _matchString(String text) {
    var i = 0;
    if (_ch == text.codeUnitAt(0)) {
      i++;
      if (_pos + text.length <= _source.length) {
        for (; i < text.length; i++) {
          if (text.codeUnitAt(i) != _source.codeUnitAt(_pos + i)) {
            break;
          }
        }
      }
    }

    ok = i == text.length;
    if (ok) {
      _pos = _pos + text.length;
      _ch = _getChar(_pos);
      return text;
    } else {
      final pos = _pos + i;
      if (_failPos < pos) {
        _failPos = pos;
      }
      return null;
    }
  }

  void _reset() {
    error = null;
    _failPos = 0;
    _failStart = 0;
    _failures = [];
    _pos = 0;
    _ch = _getChar(0);
    ok = false;
  }
}
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
